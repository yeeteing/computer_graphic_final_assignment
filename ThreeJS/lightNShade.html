<!DOCTYPE html>
<html lang="en">

<head>
	<title> three.js webgl - ShadowMesh </title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="../main.css">
</head>

<body>
	<div id="info">
		<div style="border:0; color:#f6931f; font-weight:bold; font-size:large;">
			<b>Scores</b>
			<label><span id="scores" readonly></span></label>
		</div>
		
		<div style="color: rgb(134, 211, 230)">
			<h3><b>left click to hit the objects </b></h3>
		</div>
		<div>
			<b  style="color: rgb(230, 230, 134); ">Keyboard Control:</b> 
			<div>L: Switch Light Bulb Off</div>
			<div style="display:flex; flex-direction: row; justify-content:space-around; align-items: center;">
				<div style="color: rgba(216, 42, 42, 0.863)">R: Switch Light Bulb To RED</div> <div style="color: rgb(103, 189, 77)">G: Switch Light Bulb To GREEN</div> <div style="color: rgb(0, 41, 129)">B: Switch Light Bulb To BLUE</div>
			</div>
			<div style="display:flex; flex-direction: row; justify-content:space-around; align-items: center;">
				<div>UP arrow: Move light Bulb UP</div><div>DOWN arrow: Move light Bulb DOWN</div><div>LEFT arrow: Move light Bulb LEFT</div><div>RIGHT arrow: Move light Bulb RIGHT</div>
			</div>
		</div>


	</div>

	<div id="container"></div>

	<script type="module">

		import * as THREE from '../resources/three.module.js';

		import { ShadowMesh } from 'https://unpkg.com/three/examples/jsm/objects/ShadowMesh.js';

		import { OrbitControls } from 'https://threejsfundamentals.org/threejs/resources/threejs/r125/examples/jsm/controls/OrbitControls.js';

		let SCREEN_WIDTH = window.innerWidth;
		let SCREEN_HEIGHT = window.innerHeight;

		const scene = new THREE.Scene();
		const camera = new THREE.PerspectiveCamera(55, SCREEN_WIDTH / SCREEN_HEIGHT, 1, 3000);

		const clock = new THREE.Clock();
		const renderer = new THREE.WebGLRenderer();

		// light sources
		const sunLight = new THREE.DirectionalLight('rgb(255,255,255)', 1);

		const ambientLight = new THREE.AmbientLight(0xffff00, 0.05)
		const lightLeft = new THREE.PointLight(0xffff00, 1);
		const lightRight = new THREE.PointLight(0xffff00, 1);

		let groundMesh;
		let lightSphere, lightHolder;
		let pyramid, pyramidShadow, pyramidShadow_left, pyramidShadow_right;
		let sphere, sphereShadow, sphereShadow_left, sphereShadow_right;
		let cube, cubeShadow, cubeShadow_left, cubeShadow_right;
		let cylinder, cylinderShadow, cylinderShadow_left, cylinderShadow_right;
		let torus, torusShadow, torusShadow_left, torusShadow_right;
		const normalVector = new THREE.Vector3(0, 1, 0);
		const planeConstant = 0.01; // this value must be slightly higher than the groundMesh's y position of 0.0
		const groundPlane = new THREE.Plane(normalVector, planeConstant);
		const lightPosition4D = new THREE.Vector4();
		const lightPosition4D_left = new THREE.Vector4();
		const lightPosition4D_right = new THREE.Vector4();
		let verticalAngle = 0;
		let horizontalAngle = 0;
		let frameTime = 0;
		const TWO_PI = Math.PI * 2;

		const mouseCoords = new THREE.Vector2();
		const raycaster = new THREE.Raycaster();
		const ballMaterial = new THREE.MeshPhongMaterial( { color: 0x202020 } );

		let controls;

		let sunLightX, sunLightY, sunLightZ

		init();
		animate();

		function init() {
			const container = document.querySelector('#container');
			controls = new OrbitControls(camera, container);
			controls.target.set(0, 0, 0);
			controls.update();

			scene.background = new THREE.Color(0x0096ff);

			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
			document.getElementById("container").appendChild(renderer.domElement);
			window.addEventListener('resize', onWindowResize);

			camera.position.set(0, 2.5, 10);
			scene.add(camera);
			onWindowResize();

			// top light
			sunLightX = 0
			sunLightY = 6
			sunLightZ = -1
			sunLight.position.set(sunLightX, sunLightY, sunLightZ);
			sunLight.lookAt(scene.position);
			scene.add(sunLight);
			// left light
			lightLeft.position.set(-5, 6, - 1);
			lightLeft.lookAt(scene.position);
			scene.add(lightLeft);
			// right light
			lightRight.position.set(5, 6, - 1);
			lightRight.lookAt(scene.position);
			scene.add(lightRight);

			// ambient light
			scene.add(ambientLight);
			// spot light
			// spotLight.position.set(5, 6, - 1);
			// spotLight.lookAt(scene.position);
			// scene.add(spotLight);
			// console.log("   ", controls.object.position);

			// top positions
			lightPosition4D.x = sunLight.position.x;
			lightPosition4D.y = sunLight.position.y;
			lightPosition4D.z = sunLight.position.z;
			// amount of light-ray divergence. Ranging from:
			// 0.001 = sunlight(min divergence) to 1.0 = pointlight(max divergence)
			lightPosition4D.w = 0.001; // must be slightly greater than 0, due to 0 causing matrixInverse errors

			lightPosition4D_left.x = lightLeft.position.x;
			lightPosition4D_left.y = lightLeft.position.y;
			lightPosition4D_left.z = lightLeft.position.z;
			lightPosition4D_left.w = 0.001; // must be slightly greater than 0, due to 0 causing matrixInverse errors

			lightPosition4D_right.x = lightRight.position.x;
			lightPosition4D_right.y = lightRight.position.y;
			lightPosition4D_right.z = lightRight.position.z;
			lightPosition4D_right.w = 0.001; // must be slightly greater than 0, due to 0 causing matrixInverse errors

			// LIGHTBULB
			const lightSphereGeometry = new THREE.SphereGeometry(0.09);
			const lightSphereMaterial = new THREE.MeshBasicMaterial({ color: 'rgb(255,255,0)' });
			lightSphere = new THREE.Mesh(lightSphereGeometry, lightSphereMaterial);
			scene.add(lightSphere);
			lightSphere.visible = true;
			lightSphere.position.copy(sunLight.position);
			//
			// lightSphere.castShadow = true;

			const lightHolderGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.13);
			const lightHolderMaterial = new THREE.MeshBasicMaterial({ color: 'rgb(75,75,75)' });
			lightHolder = new THREE.Mesh(lightHolderGeometry, lightHolderMaterial);
			scene.add(lightHolder);
			lightHolder.visible = true;
			lightHolder.position.copy(lightSphere.position);

			// GROUND
			const groundGeometry = new THREE.BoxGeometry(30, 0.01, 40);
			const groundMaterial = new THREE.MeshLambertMaterial({ color: 'rgb(0,130,0)' });
			groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
			groundMesh.position.y = 0.0; //this value must be slightly lower than the planeConstant (0.01) parameter above
			scene.add(groundMesh);

			// RED CUBE and CUBE's SHADOW
			const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
			const cubeMaterial = new THREE.MeshLambertMaterial({ color: 'rgb(255,0,0)', emissive: 0x200000 });
			cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
			cube.position.z = - 1;
			scene.add(cube);

			cubeShadow = new ShadowMesh(cube);
			scene.add(cubeShadow);

			cubeShadow_left = new ShadowMesh(cube);
			scene.add(cubeShadow_left);

			cubeShadow_right = new ShadowMesh(cube);
			scene.add(cubeShadow_right);

			cubeShadow_left.material.color.setHex(0xfff600);
			cubeShadow_right.material.color.setHex(0xff6600);

			// BLUE CYLINDER and CYLINDER's SHADOW
			const cylinderGeometry = new THREE.CylinderGeometry(0.3, 0.3, 2);
			const cylinderMaterial = new THREE.MeshPhongMaterial({ color: 'rgb(0,0,255)', emissive: 0x000020 });
			cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
			cylinder.position.z = - 2.5;
			scene.add(cylinder);

			cylinderShadow = new ShadowMesh(cylinder);
			scene.add(cylinderShadow);

			cylinderShadow_left = new ShadowMesh(cylinder);
			scene.add(cylinderShadow_left);

			cylinderShadow_right = new ShadowMesh(cylinder);
			scene.add(cylinderShadow_right);

			cylinderShadow_left.material.color.setHex(0xfff600);
			cylinderShadow_right.material.color.setHex(0xff6600);

			// MAGENTA TORUS and TORUS' SHADOW
			const torusGeometry = new THREE.TorusGeometry(1, 0.2, 10, 16, TWO_PI);
			const torusMaterial = new THREE.MeshPhongMaterial({ color: 'rgb(255,0,255)', emissive: 0x200020 });
			torus = new THREE.Mesh(torusGeometry, torusMaterial);
			torus.position.z = - 6;
			scene.add(torus);

			torusShadow = new ShadowMesh(torus);
			scene.add(torusShadow);

			torusShadow_left = new ShadowMesh(torus);
			scene.add(torusShadow_left);

			torusShadow_right = new ShadowMesh(torus);
			scene.add(torusShadow_right);

			torusShadow_left.material.color.setHex(0xfff600);
			torusShadow_right.material.color.setHex(0xff6600);

			// WHITE SPHERE and SPHERE'S SHADOW
			const sphereGeometry = new THREE.SphereGeometry(0.5, 20, 10);
			const sphereMaterial = new THREE.MeshPhongMaterial({ color: 'rgb(255,255,255)', emissive: 0x222222 });
			sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
			sphere.position.set(4, 0.5, 2);
			scene.add(sphere);

			sphereShadow = new ShadowMesh(sphere);
			scene.add(sphereShadow);

			sphereShadow_left = new ShadowMesh(sphere);
			scene.add(sphereShadow_left);

			sphereShadow_right = new ShadowMesh(sphere);
			scene.add(sphereShadow_right);

			sphereShadow_left.material.color.setHex(0xfff600);
			sphereShadow_right.material.color.setHex(0xff6600);

			// YELLOW PYRAMID and PYRAMID'S SHADOW
			const pyramidGeometry = new THREE.CylinderGeometry(0, 0.5, 2, 4);
			const pyramidMaterial = new THREE.MeshPhongMaterial({ color: 'rgb(255,255,0)', emissive: 0x440000, shininess: 0 });
			pyramid = new THREE.Mesh(pyramidGeometry, pyramidMaterial);
			pyramid.position.set(- 4, 1, 2);
			scene.add(pyramid);

			pyramidShadow = new ShadowMesh(pyramid);
			scene.add(pyramidShadow);

			pyramidShadow_left = new ShadowMesh(pyramid);
			scene.add(pyramidShadow_left);

			pyramidShadow_right = new ShadowMesh(pyramid);
			scene.add(pyramidShadow_right);

			pyramidShadow_left.material.color.setHex(0xfff600);
			pyramidShadow_right.material.color.setHex(0xff6600);

			document.addEventListener('keydown', onKeyDown);

			document.getElementById("scores").innerHTML = "0";
			document.addEventListener('mousemove', onMouseMove);
			
			document.addEventListener( 'pointerdown', onMouseDown)
		}

		function onMouseMove(e) {
			// console.log("cqmera: ", controls.object.position);

		}

		function onMouseDown(e){
			console.log('c')
			mouseCoords.set(
					( event.clientX / window.innerWidth ) * 2 - 1,
					- ( event.clientY / window.innerHeight ) * 2 + 1
				);

				raycaster.setFromCamera( mouseCoords, camera );

				// Creates a ball and throws it
				const ballMass = 35;
				const ballRadius = 0.4;

				const ball = new THREE.Mesh( new THREE.SphereGeometry( ballRadius, 14, 10 ), ballMaterial );
				ball.castShadow = true;
				ball.receiveShadow = true;
			//	const ballShape = new Ammo.btSphereShape( ballRadius );
				ballShape.setMargin( margin );
				pos.copy( raycaster.ray.direction );
				pos.add( raycaster.ray.origin );
				quat.set( 0, 0, 0, 1 );
				const ballBody = createRigidBody( ball, ballShape, ballMass, pos, quat );

				pos.copy( raycaster.ray.direction );
				pos.multiplyScalar( 24 );
			//	ballBody.setLinearVelocity( new Ammo.btVector3( pos.x, pos.y, pos.z ) );

		}

		function animate() {

			requestAnimationFrame(animate);

			frameTime = clock.getDelta();

			cube.rotation.x += 1.0 * frameTime;
			cube.rotation.y += 1.0 * frameTime;

			cylinder.rotation.y += 1.0 * frameTime;
			cylinder.rotation.z -= 1.0 * frameTime;

			torus.rotation.x -= 1.0 * frameTime;
			torus.rotation.y -= 1.0 * frameTime;

			pyramid.rotation.y += 2.0 * frameTime;
			pyramid.rotation.z -= 2.0 * frameTime;

			sphere.rotation.x -= 1.0 * frameTime;
			sphere.rotation.y -= 1.0 * frameTime;

			horizontalAngle += 0.5 * frameTime;
			if (horizontalAngle > TWO_PI)
				horizontalAngle -= TWO_PI;
			cube.position.x = Math.sin(horizontalAngle) * 4;
			cylinder.position.x = Math.sin(horizontalAngle) * - 4;
			torus.position.x = Math.cos(horizontalAngle) * 4;
			sphere.position.x = Math.cos(horizontalAngle) * 4;

			verticalAngle += 1.5 * frameTime;
			if (verticalAngle > TWO_PI)
				verticalAngle -= TWO_PI;
			cube.position.y = Math.sin(verticalAngle) * 2 + 2.9;
			cylinder.position.y = Math.sin(verticalAngle) * 2 + 3.1;
			torus.position.y = Math.cos(verticalAngle) * 2 + 3.3;

			// update the ShadowMeshes to follow their shadow-casting objects
			cubeShadow.update(groundPlane, lightPosition4D);
			cylinderShadow.update(groundPlane, lightPosition4D);
			torusShadow.update(groundPlane, lightPosition4D);
			sphereShadow.update(groundPlane, lightPosition4D);
			pyramidShadow.update(groundPlane, lightPosition4D);

			cubeShadow_left.update(groundPlane, lightPosition4D_left);
			cylinderShadow_left.update(groundPlane, lightPosition4D_left);
			torusShadow_left.update(groundPlane, lightPosition4D_left);
			sphereShadow_left.update(groundPlane, lightPosition4D_left);
			pyramidShadow_left.update(groundPlane, lightPosition4D_left);

			cubeShadow_right.update(groundPlane, lightPosition4D_right);
			cylinderShadow_right.update(groundPlane, lightPosition4D_right);
			torusShadow_right.update(groundPlane, lightPosition4D_right);
			sphereShadow_right.update(groundPlane, lightPosition4D_right);
			pyramidShadow_right.update(groundPlane, lightPosition4D_right);

			renderer.render(scene, camera);

		}

		function onWindowResize() {

			SCREEN_WIDTH = window.innerWidth;
			SCREEN_HEIGHT = window.innerHeight;

			renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);

			camera.aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
			camera.updateProjectionMatrix();

		}

		function onKeyDown(event) {

			var delta = 20;
			console.log(event.keyCode)

			switch (event.keyCode) {				
				case 76: /* L */
						sunLight.visible = !sunLight.visible;
						// shadows
						cubeShadow.visible = sunLight.visible;
						cylinderShadow.visible = sunLight.visible;
						torusShadow.visible = sunLight.visible;
						sphereShadow.visible = sunLight.visible;
						pyramidShadow.visible = sunLight.visible;
					
					break;
				case 82: /* R */
					sunLight.color.setRGB(1, 0, 0)
					break;
				case 71: /* G */
					sunLight.color.setRGB(0, 1, 0)
					break;
				case 66: /* B */
					sunLight.color.setRGB(0, 0, 1)
					break;
				case 87: /* W */
					sunLight.color.setRGB(1, 1, 1)
					break;
				case 38: /* up */	
					sunLightY +=1
					sunLight.position.set(sunLightX, sunLightY, sunLightZ);
					sunLight.lookAt(scene.position);

					lightSphere.position.copy(sunLight.position);
					lightHolder.position.copy(lightSphere.position);
					lightPosition4D.x = sunLight.position.x;
					console.log(lightHolder.position)
					lightPosition4D.y = sunLight.position.y;
					lightPosition4D.z = sunLight.position.z;
					lightPosition4D.w = 0.9; // more of a point Light value
					break;
					
				case 37: /* left */
					sunLightX -= 1
					sunLight.position.set(sunLightX, sunLightY, sunLightZ);
					sunLight.lookAt(scene.position);

					lightSphere.position.copy(sunLight.position);
					lightHolder.position.copy(lightSphere.position);
					lightPosition4D.x = sunLight.position.x;
					console.log(lightHolder.position)
					lightPosition4D.y = sunLight.position.y;
					lightPosition4D.z = sunLight.position.z;
					lightPosition4D.w = 0.9; // more of a point Light value
					break;
				case 39: /* right */
					sunLightX += 1
					sunLight.position.set(sunLightX, sunLightY, sunLightZ);
					sunLight.lookAt(scene.position);

					lightSphere.position.copy(sunLight.position);
					lightHolder.position.copy(lightSphere.position);
					console.log(lightHolder.position)
					lightPosition4D.x = sunLight.position.x;
					lightPosition4D.y = sunLight.position.y;
					lightPosition4D.z = sunLight.position.z;
					lightPosition4D.w = 0.9; // more of a point Light value
					break;
				case 40: /* down */
					sunLightY -=1
					sunLight.position.set(sunLightX, sunLightY, sunLightZ);
					sunLight.lookAt(scene.position);

					lightSphere.position.copy(sunLight.position);
					lightHolder.position.copy(lightSphere.position);
					lightPosition4D.x = sunLight.position.x;
					console.log(lightHolder.position)
					lightPosition4D.y = sunLight.position.y;
					lightPosition4D.z = sunLight.position.z;
					lightPosition4D.w = 0.9; // more of a point Light value
			}
		}

	</script>
</body>

</html>